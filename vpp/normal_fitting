#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Apr 12 00:02:00 2022

@author: domi
"""

def normal_fitting(df, oriDF, col_index, distance=1, CIlim=0.95):
    """checks whether df is a tuple - from split df due to NAs. If yes, find peaks in boths, then fit
    normal distri to merged prominence values then plot it on common graph
    HAVE TO SAVE DF AS TUPLE EVEN IF ONLY ONE"""

    prominences = []
    peaks_low = []
    peaks = []
    prominences_low = []
    prominences_high = []
    oriDF = oriDF.resample(str(distance) + "h").mean()
    dfLIST = [df[i].resample(str(distance) + "h").mean() for i in range(len(df))]
    df = tuple(dfLIST)

    # if type(df) is tuple:                    #if tuple, merge prom values from all sections
    for i in range(len(df)):
        prominences, peaks_low, peaks, prominences_low, prominences_high = get_prominences(df=df[i],
                                                                                           col_index=col_index,
                                                                                           prominences=prominences,
                                                                                           peaks_low=peaks_low,
                                                                                           peaks=peaks,
                                                                                           prominences_low=prominences_low,
                                                                                           prominences_high=prominences_high)
    prominences = np.concatenate(prominences)

    # fitting gamma to prominences
    m, sd = stats.norm.fit(prominences)  # beta=scale
    xhist = plt.hist(prominences, density=True,
                     color="grey", alpha=0.5)
    quantile = np.linspace(stats.norm.ppf(0.001, loc=m, scale=sd),
                           stats.norm.ppf(0.999, loc=m, scale=sd), 1000)
    CI = stats.norm.interval(CIlim, loc=m, scale=sd)
    print(CI)
    R = stats.norm.pdf(quantile, loc=m, scale=sd)
    plt.vlines(x=[CI[1], CI[0]], ymin=min(R), ymax=max(R), color=["red", "green"], linestyle="dashed")
    plt.plot(quantile, R, color="darkblue")
    plt.show()

    plt.figure(figsize=(16, 5))
    plt.plot(oriDF.index, oriDF.iloc[:, col_index], 'pink', label='data', alpha=0.3)
    # plt.plot(testSlice1.index, testSlice1.iloc[:,1], 'violet', label='data',alpha=0.7)
    # plt.plot(testSlice2.index, testSlice2.iloc[:,1], 'violet', label='data',alpha=0.7)
    for i in range(len(peaks)):
        peaksGammaHigh = peaks[i][prominences_high[i] > CI[1]]
        peaksGammaLow = peaks_low[i][prominences_low[i] < CI[0]]
        plt.scatter(df[i].index[peaksGammaHigh], df[i].iloc[:, col_index][peaksGammaHigh], color="red")
        plt.scatter(df[i].index[peaksGammaLow], df[i].iloc[:, col_index][peaksGammaLow], color="green")
        # plt.plot(col2analyse.index, col2analyse, 'pink', label='data',alpha=0.5)
        plt.plot(df[i].index, df[i].iloc[:, col_index], 'violet', label='data', alpha=0.5)
        # plt.plot(df.index, inversed_col, 'darkblue', label='data',alpha=0.5)
    plt.show()
